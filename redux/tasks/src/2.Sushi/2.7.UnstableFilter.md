В этом задании нужно добиться, чтобы меню реально фильтровалось. Строить список отфильтрованных блюд будем через API.
Для этого маленького приложения это избыточно: меню можно было отфильтровать прямо в браузере, но через API интереснее.

После предыдущего задания в `state` появился слайс `chosenProducts` примерно такой структуры:

```js
const state = {
  /* ... */
  chosenProducts = {
    tags: [ProductTag.hot, ProductTag.veg],
    ids: [1, 5],
    status: Status.loaded
  }
  /* ... */
}
```

1. Сейчас меню всегда показывает полный список продуктов. Надо сделать так,
   чтобы после успешной загрузки отфильтрованного списка продуктов, отображался он.
   Для этого надо изменить контейнер `Menu` вот так:

```js
import React from "react";
import { connect } from "react-redux";
import Menu from "../components/Menu";
import Status from "../constants/Status";

export default connect(
  (state, props) => ({
    productIds: getProductIds(state.products, state.chosenProducts),
    productsStatus: getProductStatus(state.products, state.chosenProducts),
  }),
  (dispatch, props) => ({})
)(Menu);

function getProductStatus(products, chosenProducts) {
  // если идет загрузка — ждем
  if (
    chosenProducts.status === Status.loading ||
    products.status === Status.loading
  ) {
    return Status.loading;
  }
  // загрузка не идет, а продукты загружены — можно показывать
  if (products.status === Status.loaded) {
    return Status.loaded;
  }
  // ничего нет и не предполагается
  return Status.none;
}

function getProductIds(products, chosenProducts) {
  // если загружен список отфильтрованных продуктов — используем его
  if (chosenProducts.status === Status.loaded) {
    return chosenProducts.ids;
  }
  // если хотя бы обычный список продуктов загружен — используем его
  if (products.status === Status.loaded) {
    return products.allIds;
  }
  return [];
}
```

2. Добавь новый типы действий:

- `LOAD_BY_TAGS_REQUEST` для запроса отфильтрованных продуктов
- `LOAD_BY_TAGS_SUCCESS` для отображения отфильтрованных продуктов после успеха
- `LOAD_BY_TAGS_FAILURE` для обработки ошибок запроса отфильтрованных продуктов

3. Добавь и подключи case-функции для обработки новых действий к редьюсеру:

```js
// после запроса нужно показать лоадер, а для этого поменять состояние
function loadByTagsRequest(state, action) {
  return {
    ...state,
    status: Status.loading,
  };
}

// в случае успеха загруженные идентификаторы надо сохранить
function loadByTagsSuccess(state, { productIds }) {
  return {
    ...state,
    ids: productIds,
    status: Status.loaded,
  };
}

// ошибка переводит фильтры в состояние «по умолчанию»
function loadByTagsFailure(state, { productIds }) {
  return {
    ...state,
    tags: [],
    ids: [],
    status: Status.none,
  };
}
```

4. Наконец, самое важное. Надо сделать так, чтобы обновление галочек в фильтрах
   приводило к вызову `api.fetchProductIdsByTags`, чтобы API вернуло список продуктов в соответствие с фильтром.
   Для этого можно изменить логику контейнера `MenuFilter` так, чтобы после обновления галочки
   вызывался `fetchProductIdsByTags`, а после успешного завершения запроса диспатчилось действие `LOAD_BY_TAGS_SUCCESS`.
   Примерно так (не спеши копировать этот код, он нерабочий):

```js
connect(
  (state, props) => ({
    chosenTags: state.chosenProducts.tags,
  }),
  (dispatch, props) => ({
    onChange: (productTag) => {
      dispatch(changeProductTag(productTag));

      dispatch({
        type: actionTypes.LOAD_BY_TAGS_REQUEST,
      });
      api.fetchProductIdsByTags(tags).then((productIds) => {
        dispatch({
          type: actionTypes.LOAD_BY_TAGS_SUCCESS,
          productIds: productIds,
        });
      });
    },
  })
)(MenuFilter);
```

У этого кода много проблем:

- Откуда взять `api`? Api создается на уровне приложения в `index.js`
- Чтобы вызвать `fetchProductIdsByTags` нужно передать все `chosenTags`,
  а не только `productTag`, текущее значение одной из галочек.
- Приходится модифицировать контейнер, чтобы изменить поведение приложения при переключении галочки,
  хотя контейнер должен об этом только сообщать куда следует и не должен отвечать за дальнейшую обработку.
  Осознай все эти проблемы, а затем переходи к следующему шагу.

5. Красивое решение описанных проблем — redux-thunk.
   Это middleware, который позволяет передавать функции, порождающие действия, вместо действий.
   Причем этим функциям доступны `getState` и `dispatch` и дополнительный аргумент.

- Импортируй `thunk` из `redux-thunk` в `index.js`:

```js
import thunk from "redux-thunk";
```

- Добавь `thunk.withExtraArgument(api)` первым параметром в `applyMiddleware`
  Теперь поменяй тривиальную реализацию `changeProductTag` в `actionCreators/index.js` на такую:

```js
export const changeProductTag = (productTag) => (dispatch, getState, api) => {
  dispatch({
    type: actionTypes.CHANGE_PRODUCT_TAG,
    productTag,
  });
};
```

В этой реализации, которая будет обработана thunk middleware, доступно все необходимое, чтобы сделать запрос к API.
Перед тем, как переходить к следующему шагу убедись, что до сих пор галочки переключаются.

6. Сделай так, чтобы `changeProductTag` выполнял последовательно следующее:

- создавал действие переключение галочки (уже делает)
- уведомлял о начале загрузки (`LOAD_BY_TAGS_REQUEST`)
- производил загрузку через `api`
- создавал действие успешной загрузки с полученными `productIds` (`LOAD_BY_TAGS_SUCCESS`)
  Другими словами все то, что выше предлагалось сделать в контейнере `MenuFilter`.
  Кстати, код неудачной версии контейнера `MenuFilter` удобно взять за основу новой версии `changeProductTag`.
  После убедись, что фильтры полностью работают.

7. С Promise в JavaScript можно работать удобнее, если использовать async/await
   Добавь слово `async` в заголовок `changeProductTag`:

```js
export const changeProductTag = productTag => async (dispatch, getState, api) => { /* ... * / }
```

Тогда можно использовать `await` вот так:

```js
const productIds = await api.fetchProductIdsByTags(tags);
```

Сделай это, а затем добавь «отправку метрик» после завершения запроса:

```js
await api.sendMetric("changeProductTag", "used");
```

8. Запросы к API могут заканчиваться ошибками и их надо обрабатывать.
   Чтобы просимулировать это замени вызов `fetchProductIdsByTags` на `fetchProductIdsByTagsUnstable`.
   Нестабильный метод API падает в половине случаев.
   Теперь если несколько раз переключить фильтр, появится ошибка в консоли и бесконечный лоадер.
   В случае использования async/await удобно обрабатывать ошибки: надо просто обернуть код в try-catch.
   Оберни `fetchProductIdsByTagsUnstable` в try, а catch напиши так:

```js
catch (error) {
    dispatch({
      type: actionTypes.LOAD_BY_TAGS_FAILURE
    });
  }
```

Теперь в случае возникновения ошибки фильтры будут сбрасываться.

9. Функция `changeProductTag` сейчас довольно большая из нее стоит выделить часть,
   которая относится непосредственно к загрузке.
   Если сделать у этой функции сигнатуру как у thunk, то ее можно будет передавать в dispatch:

```js
// заглушка под функцию
const loadByTags = () => async (dispatch, getState, api) => {
  /* ... */
};

// использование
await dispatch(loadByTags());
```

Такая сигнатура возволит использовать `loadByTags` отдельно от `changeProductTag` как action creator.
Выдели и используй `loadByTags`. `sendMetric` должен остаться вне `loadByTags`.
Обрати внимание, что благодаря использованию `redux-thunk`, `dispatch` возвращает Promise.
Поэтому можно использовать `await`, чтобы дождаться окончания выполнения `loadByTags`,
а затем отправить метрики вне зависимости от успешности `loadByTags`.
